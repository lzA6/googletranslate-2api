项目 'googletranslate-2api' 的结构树:
📂 googletranslate-2api/
    📄 .env
    📄 .env.example
    📄 Dockerfile
    📄 docker-compose.yml
    📄 main.py
    📄 nginx.conf
    📄 requirements.txt
    📂 app/
        📂 core/
            📄 __init__.py
            📄 config.py
        📂 providers/
            📄 __init__.py
            📄 base_provider.py
            📄 googletranslate_provider.py
        📂 utils/
            📄 sse_utils.py
================================================================================

--- 文件路径: .env ---

API_MASTER_KEY=1

# --- 部署配置 (可选) ---
# Nginx 对外暴露的端口
NGINX_PORT=8088

# --- Google Translate 凭证 (必须设置) ---
# 请从浏览器开发者工具的网络请求中找到 `translateHtml` 请求，
# 并复制其请求头中的 `x-goog-api-key` 值。
GOOGLE_API_KEY="AIzaSyATBXajvzQLTDHEQbcpq0Ihe0vWDHmO520"

--- 文件路径: .env.example ---

# ====================================================================
# googletranslate-2api 配置文件模板
# ====================================================================
#
# 请将此文件重命名为 ".env" 并填入您的凭证。
#

# --- 核心安全配置 (必须设置) ---
# 用于保护您 API 服务的访问密钥。
API_MASTER_KEY=sk-googletranslate-2api-default-key-please-change-me

# --- 部署配置 (可选) ---
# Nginx 对外暴露的端口
NGINX_PORT=8088

# --- Google Translate 凭证 (必须设置) ---
# 请从浏览器开发者工具的网络请求中找到 `translateHtml` 请求，
# 并复制其请求头中的 `x-goog-api-key` 值。
GOOGLE_API_KEY="AIzaSyATBXajvzQLTDHEQbcpq0Ihe0vWDHmO520"


--- 文件路径: Dockerfile ---

# ====================================================================
# Dockerfile for googletranslate-2api (v1.0 - Chimera Synthesis)
# ====================================================================

FROM python:3.10-slim

# 设置环境变量
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1
WORKDIR /app

# 安装 Python 依赖
COPY requirements.txt .
RUN pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY . .

# 创建并切换到非 root 用户
RUN useradd --create-home appuser && \
    chown -R appuser:appuser /app
USER appuser

# 暴露端口并启动
EXPOSE 8000
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000", "--workers", "1"]


--- 文件路径: docker-compose.yml ---

services:
  nginx:
    image: nginx:latest
    container_name: googletranslate-2api-nginx
    restart: always
    ports:
      - "${NGINX_PORT:-8088}:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - app
    networks:
      - googletranslate-net

  app:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: googletranslate-2api-app
    restart: unless-stopped
    env_file:
      - .env
    networks:
      - googletranslate-net

networks:
  googletranslate-net:
    driver: bridge


--- 文件路径: main.py ---

import sys
from contextlib import asynccontextmanager
from typing import Optional

from fastapi import FastAPI, Request, HTTPException, Depends, Header
from fastapi.responses import JSONResponse, StreamingResponse
from loguru import logger

from app.core.config import settings
from app.providers.googletranslate_provider import GoogleTranslateProvider

# --- 配置 Loguru ---
logger.remove()
logger.add(
    sys.stdout,
    level="INFO",
    format="<green>{time:YYYY-MM-DD HH:mm:ss.SSS}</green> | "
           "<level>{level: <8}</level> | "
           "<cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>",
    colorize=True
)

# --- 全局 Provider 实例 ---
provider = GoogleTranslateProvider()

@asynccontextmanager
async def lifespan(app: FastAPI):
    logger.info(f"应用启动中... {settings.APP_NAME} v{settings.APP_VERSION}")
    await provider.initialize()
    logger.info(f"服务将在 http://localhost:{settings.NGINX_PORT} 上可用")
    yield
    await provider.close()
    logger.info("应用关闭。")

app = FastAPI(
    title=settings.APP_NAME,
    version=settings.APP_VERSION,
    description=settings.DESCRIPTION,
    lifespan=lifespan
)

# --- 安全依赖 ---
async def verify_api_key(authorization: Optional[str] = Header(None)):
    if settings.API_MASTER_KEY and settings.API_MASTER_KEY != "1":
        if not authorization or "bearer" not in authorization.lower():
            raise HTTPException(status_code=401, detail="需要 Bearer Token 认证。")
        token = authorization.split(" ")[-1]
        if token != settings.API_MASTER_KEY:
            raise HTTPException(status_code=403, detail="无效的 API Key。")

# --- API 路由 ---
@app.post("/v1/chat/completions", dependencies=[Depends(verify_api_key)])
async def chat_completions(request: Request):
    try:
        request_data = await request.json()
        return await provider.chat_completion(request_data)
    except Exception as e:
        logger.error(f"处理聊天请求时发生顶层错误: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"内部服务器错误: {str(e)}")

@app.get("/v1/models", dependencies=[Depends(verify_api_key)])
async def list_models():
    return await provider.get_models()

@app.get("/", summary="根路径", include_in_schema=False)
def root():
    return {"message": f"欢迎来到 {settings.APP_NAME} v{settings.APP_VERSION}. 服务运行正常。"}


--- 文件路径: nginx.conf ---

worker_processes auto;

events {
    worker_connections 1024;
}

http {
    upstream googletranslate_backend {
        # API 是无状态的，无需 ip_hash
        server app:8000;
    }

    server {
        listen 80;
        server_name localhost;

        location / {
            proxy_pass http://googletranslate_backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # 流式传输优化
            proxy_buffering off;
            proxy_cache off;
            proxy_set_header Connection '';
            proxy_http_version 1.1;
            chunked_transfer_encoding off;
        }
    }
}


--- 文件路径: requirements.txt ---

fastapi
uvicorn[standard]
httpx
pydantic-settings
python-dotenv
loguru
beautifulsoup4
markdownify


--- 文件路径: app\core\__init__.py ---



--- 文件路径: app\core\config.py ---

from pydantic_settings import BaseSettings, SettingsConfigDict
from typing import Optional, List

class Settings(BaseSettings):
    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding='utf-8',
        extra="ignore"
    )

    APP_NAME: str = "googletranslate-2api"
    APP_VERSION: str = "1.0.0"
    DESCRIPTION: str = "一个将 Google Translate API 转换为兼容 OpenAI 格式的代理。"

    API_MASTER_KEY: Optional[str] = None
    NGINX_PORT: int = 8088
    
    GOOGLE_API_KEY: Optional[str] = None

    API_REQUEST_TIMEOUT: int = 60

    DEFAULT_MODEL: str = "google-translate"
    KNOWN_MODELS: List[str] = ["google-translate"]

settings = Settings()


--- 文件路径: app\providers\__init__.py ---



--- 文件路径: app\providers\base_provider.py ---

from abc import ABC, abstractmethod
from typing import Dict, Any
from fastapi.responses import StreamingResponse, JSONResponse

class BaseProvider(ABC):
    @abstractmethod
    async def chat_completion(self, request_data: Dict[str, Any]) -> StreamingResponse:
        pass

    @abstractmethod
    async def get_models(self) -> JSONResponse:
        pass


--- 文件路径: app\providers\googletranslate_provider.py ---

import httpx
import json
import time
import uuid
import re
from typing import Dict, Any, AsyncGenerator, Optional

from fastapi import HTTPException
from fastapi.responses import StreamingResponse, JSONResponse
from loguru import logger
from markdownify import markdownify as md
from bs4 import BeautifulSoup

from app.core.config import settings
from app.providers.base_provider import BaseProvider
from app.utils.sse_utils import create_sse_data, create_chat_completion_chunk, DONE_CHUNK

class GoogleTranslateProvider(BaseProvider):
    BASE_URL = "https://translate-pa.googleapis.com/v1/translateHtml"
    CHINESE_REGEX = re.compile(r'[\u4e00-\u9fa5]')

    def __init__(self):
        self.client: Optional[httpx.AsyncClient] = None

    async def initialize(self):
        if not settings.GOOGLE_API_KEY:
            raise ValueError("GOOGLE_API_KEY 未在 .env 文件中配置。")
        self.client = httpx.AsyncClient(timeout=settings.API_REQUEST_TIMEOUT)

    async def close(self):
        if self.client:
            await self.client.aclose()

    async def chat_completion(self, request_data: Dict[str, Any]) -> StreamingResponse:
        
        async def stream_generator() -> AsyncGenerator[bytes, None]:
            request_id = f"chatcmpl-{uuid.uuid4()}"
            model_name = request_data.get("model", settings.DEFAULT_MODEL)
            
            try:
                headers = self._prepare_headers()
                payload = self._prepare_payload(request_data)
                
                logger.info(f"向上游发送翻译请求: {payload}")
                
                response = await self.client.post(self.BASE_URL, headers=headers, json=payload)
                
                logger.info(f"上游响应状态码: {response.status_code}")
                response.raise_for_status()
                
                response_data = response.json()
                logger.info(f"收到上游响应: {response_data}")

                # --- 健壮的响应解析逻辑 (已修改) ---
                translated_html = ""
                if isinstance(response_data, list) and response_data:
                    if isinstance(response_data[0], list) and response_data[0]:
                        # 正常情况，获取翻译后的 HTML
                        translated_html = response_data[0][0]
                elif not isinstance(response_data, list):
                    # 如果响应不是列表，则为异常情况
                    raise ValueError(f"上游响应格式不符合预期: {response_data}")
                # 如果 response_data 是空列表 `[]`，则 translated_html 保持为空字符串，这是正常情况

                # --- 增强的文本清理 ---
                soup = BeautifulSoup(translated_html, 'html.parser')
                clean_text = soup.get_text()
                # 移除零宽空格等不可见字符
                clean_text = clean_text.replace('\u200b', '')

                # 将清理后的文本转换为 Markdown
                markdown_text = md(clean_text)

                # 发送包含完整翻译结果的单个数据块
                chunk = create_chat_completion_chunk(request_id, model_name, markdown_text)
                yield create_sse_data(chunk)
                
                # 发送结束标志
                final_chunk = create_chat_completion_chunk(request_id, model_name, "", "stop")
                yield create_sse_data(final_chunk)
                yield DONE_CHUNK

            except Exception as e:
                logger.error(f"处理翻译请求时发生错误: {e}", exc_info=True)
                error_message = f"内部服务器错误: {str(e)}"
                error_chunk = create_chat_completion_chunk(request_id, model_name, error_message, "stop")
                yield create_sse_data(error_chunk)
                yield DONE_CHUNK

        return StreamingResponse(stream_generator(), media_type="text/event-stream")

    def _prepare_headers(self) -> Dict[str, str]:
        # (已修改) 添加了 User-Agent 来模拟真实浏览器请求
        return {
            "Accept": "*/*",
            "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8",
            "Content-Type": "application/json+protobuf",
            "Origin": "https://stackoverflow.ai",
            "Referer": "https://stackoverflow.ai/",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36",
            "x-goog-api-key": settings.GOOGLE_API_KEY,
        }

    def _prepare_payload(self, request_data: Dict[str, Any]) -> list:
        messages = request_data.get("messages", [])
        if not messages or messages[-1].get("role") != "user":
            raise HTTPException(status_code=400, detail="请求中缺少有效的用户消息。")
        
        content = messages[-1]["content"]
        # 如果 content 为空或 None，API 可能会返回错误或空内容，这里我们将其视为空字符串
        text_to_translate = content if content is not None else ""
        
        # 智能语言路由逻辑
        source_lang = request_data.get("source_lang", "auto")
        target_lang = request_data.get("target_lang")

        if not target_lang:
            # 如果用户未指定目标语言，则自动判断
            if self.CHINESE_REGEX.search(text_to_translate):
                target_lang = "en" # 输入是中文，默认翻译成英文
                logger.info("检测到中文输入，自动设置目标语言为 'en'")
            else:
                target_lang = "zh-CN" # 输入是其他语言，默认翻译成中文
                logger.info("未检测到中文输入，自动设置目标语言为 'zh-CN'")
        
        return [
            [[text_to_translate], source_lang, target_lang],
            "te_lib"
        ]

    async def get_models(self) -> JSONResponse:
        model_data = {
            "object": "list",
            "data": [
                {"id": name, "object": "model", "created": int(time.time()), "owned_by": "lzA6"}
                for name in settings.KNOWN_MODELS
            ]
        }
        return JSONResponse(content=model_data)


--- 文件路径: app\utils\sse_utils.py ---

import json
import time
from typing import Dict, Any, Optional

DONE_CHUNK = b"data: [DONE]\n\n"

def create_sse_data(data: Dict[str, Any]) -> bytes:
    """将字典数据格式化为 SSE 事件字符串。"""
    return f"data: {json.dumps(data)}\n\n".encode('utf-8')

def create_chat_completion_chunk(
    request_id: str,
    model: str,
    content: str,
    finish_reason: Optional[str] = None
) -> Dict[str, Any]:
    """
    创建一个与 OpenAI 兼容的聊天补全流式块。
    """
    return {
        "id": request_id,
        "object": "chat.completion.chunk",
        "created": int(time.time()),
        "model": model,
        "choices": [
            {
                "index": 0,
                "delta": {"content": content},
                "finish_reason": finish_reason
            }
        ]
    }



